# Chapter 6　物理プランの生成

## 物理プラン生成の位置付け

![sql_process](img/sql_process.png)


1. SQL文を構文解析して構文ツリーを作成する。
カタログ情報を参照して整合性をチェックして、構文ツリーをプランナに渡す。

2. プランナは関係代数の演算を用いて論理プランを作成する。
論理プランは関係代数の規則や性質を利用して、より効率の良いものが生成される。この時点でどんな演算をすればSQL文の回答を生成できるかが判明する。


3. プランナは論理プランから物理プランを生成する。
その際に実行エンジンが持つ機能モジュールをどんな順番で実行するのが最適かを検討する。生成した物理プランを実行エンジンに渡す。

4. 実行エンジンは物理プランを受け取り、プラン内の処理の順序に従って、各種機能モジュールを動作させ、SQL文の答えを作成する。
ここで初めて、ディスク上に存在するデータを読み書きする。

物理プランを生成するということは論理プランに記述された関係代数の演算を、実行エンジンの最適な処理手順に記述し直すことである。


## 物理プランの最適化とは

- SQL文
```
SELECT 従業員名, 部署名 FROM 従業員テーブル, 部署テーブル
WHERE 従業員テーブル.部署番号 = 部署テーブル.部署番号
AND 性別 = '男'
```

- テーブル
![table_sample](img/table_sample.png)

- 論理プラン

	- 従業員テーブルで、性別が「男」のタプルを選択する
	- 上の結果と部署テーブルとの直積を求め部署番号が等しいタプルを選択する
	- 結果から従業員名と部署名のみを射影して出力する

- 物理プラン

	- 従業員テーブルで、性別が「男」のタプルを選択する
		- 性別カラムのインデックスを使用して「男」のタプルを見つける
			⇨インデックススキャンモジュール
		- 従業員テーブルの全レコードをチェックして性別が「男」のものを見つける
		 	⇨テーブルスキャンモジュール
	- 上の結果と部署テーブルとの直積を求め部署番号が等しいタプルを選択する
		- データベースが搭載している結合処理の数だけ選択肢がある
			⇨ネストループ結合モジュール
            ⇨ソートマージ結合モジュール
            ⇨ハッシュ結合モジュール

	- 結果から従業員名と部署名のみを射影して出力する
		⇨フィルタモジュール

	```
	2種類 × 3種類 × 1種類 = 6種類の物理プラン
    ``` 
    
    この6種類から最良と思われる物理プランを見つける
    
- 最適な物理プランとは？

	- 実行する処理時間が一番短いもの
		- データファイルのフラグメンテーションやCPUやディスクI/Oの負荷に左右される
		実際に計測するのは難しいので、何らかの指標を用いて予想を立てる。
        
        - 複雑なSELECT文になればプランの選択肢は増える
        	⇨プランの最適化に多くの処理時間を費やしては本末転等

	最適な物理プランの生成は、データベースシステムにとって非常に重要な課題。


## 物理プランの最適化方式

「ルールベース方式」と「コストベース方式」がメジャー
実用化されていないものも存在する。

### ルールベース方式

比較的古くから実用化されている方式。
事前に物理プラン選択の優先順位を定義したルールを用意して、該当する物理プランのうち、一番優先度の高いものを選択する。

Oracleは9iまでルールベース方式を使用していた。

|優先順位|アクセスパス
| :--: | :--: |
| 1 | ROWID による単一行|
| 2 | クラスタ結合による単一行|
| 3 | 一意キー or 主キーのハッシュ・クラスタ・キーによる単一行|
| 4 | 一意キー or 主キーによる単一行|
| 5 | クラスタ結合|
| 6 | ハッシュ・クラスタ・キー|
| 7 | インデックスクラスタ・キー|
| 8 | 複合列によるインデックス（複合インデックス／旧名？：連結インデックス）|
| 9 | 単一列によるインデックス|
| 10 | インデックスレンジスキャン（上下限つき、前方一致）|
| 11 | インデックスレンジスキャン（上限または下限）|
| 12 | ソート・マージ結合|
| 13 | インデックス列の MAX、MIN|
| 14 | インデックス列の ORDER BY|
| 15 | テーブルフルスキャン|


### コストベース方式

カタログ内の各種統計情報を参照してコストと呼ばれる最適化の指標を算出する。そのコストの値が最も小さい物理プランを選択する。

ex)カラムにインデックスが存在していても、データ量が極めて小さいテーブルの場合、テーブルスキャンが実施される。
この後、データ数が増えていくとインデックススキャンが選択されるようになる。
⇨（データの統計情報が正しく更新されている場合）

一般的にコストベース方式の方がルールベース方式より最適なプランを生成できるため、最近のデータベースにはコストベース方式を採用したプランナが実装されている。


## コストベース方式の例

コストベースの一般的な考え方を以下の例で説明する

```
SELECT 従業員名 FROM 従業員テーブル
WHERE 出身地 = '北海道'
```

![table_sample2](img/table_sample2.png)

### インデックスが存在しない場合

出身地カラムにインデックスがない場合は、従業員テーブルのテーブルスキャン1択

### インデックスが存在する場合

#### 「テーブルスキャン」か「インデックススキャン」どちらを選択する？
「北海道」が全出身地カラムの値の中にどれ程度含まれているか？（selectivity）

- selectivityが小さい
該当のレコード数が少ない（参照するデータブロックが少ない）
インデックススキャンを使用した方がコスト低

- selectivityが大きい
該当のレコード数が多い（参照するデータブロックが多い）
インデックススキャンを使用した方がコスト高い（テーブルスキャンを使用）

※selectrivityの大小の基準はデータベースシステムによって異なり、明確な基準が存在するわけではない

#### selectivityの算出

「値の種類数」,「平均値」,「中央値」といった統計値を保持しておき、そこから算出する

※どんな統計値が用意されているかはデータベースシステムによって大きく異なる

今回の場合、「北海道」を持つレコードは１レコードしか存在しないのでインデックススキャンが採用される

### 条件が東京の場合

```
SELECT 従業員名 FROM 従業員テーブル
WHERE 出身地 = '東京'
```

- 15件中8件が対象
- selectivityは大きい
- 出身地カラムにインデックスが設定されていても「テーブルスキャン」が採用される


### 条件値が与えられなかった場合

構文解析から物理プランの作成までを行い、実際にSQL文を実行する際に条件値を与える方法。ストアドプロシージャ内でよく使用される。

```
SELECT 従業員名 FROM 従業員テーブル
WHERE 出身地 = ?
```
「テーブルスキャン」と「インデックススキャン」のどちらが良いかは物理プラン作成時点はわからない。どちらが採用されるかはデータベースシステムによって異なる。

コストベース方式を採用しても、物理プランを最適化することは難しい。

### カーディナリティ（cardinality）余談

- カラムに格納されている値の種類数

例）
性別カラムなら2~3なのでカーディナリティは低い
顧客番号は多くの種類（番号）が存在するのでカーティナリティは低い

- カーディナリティの高いカラムにインデックスを貼る
- 複合インデックスもカーディナリティの高いカラムから順にインデックスを貼る